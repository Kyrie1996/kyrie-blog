# js正则表达式

### 1.模糊匹配
1. 横向模糊匹配
   横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。其实现的方式是使用量词。譬如{m,n}，表示连续出现最少m次，最多n次。
   例:
   ``` javascript
    var regex = /ab{2,5}c/g;
    var string = "abc abbc abbbc abbbbc abbbbbc abbbbbbc";
    console.log( string.match(regex) ); 
    // => ["abbc", "abbbc", "abbbbc", "abbbbbc"]
   ```
2. 纵向模糊匹配
   纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。其实现的方式是使用字符组。譬如[abc]，表示该字符是可以字符“a”、“b”、“c”中的任何一个。
   例:
   ``` javascript
    var regex = /a[123]b/g;
    var string = "a0b a1b a2b a3b a4b";
    console.log( string.match(regex) ); 
    // => ["a1b", "a2b", "a3b"]
   ```
  #### 小结
  - 横向模糊匹配用来匹配数量，纵向模糊匹配用来匹配多种可能性。

  - 横向模糊匹配用量词，纵向模糊匹配用字符组
  
### 2.常见字符组
  ``` javascript
  \d 就是[0-9]。表示是一位数字。记忆方式：其英文是digit（数字）。
  \D 就是[^0-9]。表示除数字外的任意字符。
  \w 就是[0-9a-zA-Z_]。表示数字、大小写字母和下划线。记忆方式：w是word的简写，也称单词字符。
  \W 是[^0-9a-zA-Z_]。非单词字符。
  \s 是[ \t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s是space character的首字母。
  \S 是[^ \t\v\n\r\f]。 非空白符。
  . 就是[^\n\r\u2028\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号...中的每个点，都可以理解成占位符，表示任何类似的东西。
  ```

### 3.量词
``` javascript
  {m,} 表示至少出现m次。
  {m} 等价于{m,m}，表示出现m次。
  ? 等价于{0,1}，表示出现或者不出现。记忆方式：问号的意思表示，有吗？
  + 等价于{1,}，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。
  * 等价于{0,}，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。
```
- 通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下：
  ``` javascript
    {m,n}?
    {m,}?
    ??
    +?
    *?
  ```

### 4. 多选分支
一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。具体形式如下：(p1|p2|p3)，其中p1、p2和p3是子模式，用|（管道符）分隔，表示其中任何之一。
例: 
  ``` javascript
    var regex = /good|nice/g;
    var string = "good idea, nice try.";
    console.log( string.match(regex) ); 
    // => ["good", "nice"]
  ```
  比如我用/good|goodbye/，去匹配"goodbye"字符串时，结果是"good"：
  ``` javascript
    var regex = /goodbye|good/g;
    var string = "goodbye";
    console.log( string.match(regex) ); 
    // => ["goodbye"]
  ```
  也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。

### 5.贪婪匹配和惰性匹配
1. 贪婪匹配是先看整个字符串是否匹配，如果不匹配，它会去掉字符串的最后一个字符，并再次尝试，如果还不匹配，那么再去掉当前最后一个，直到发现匹配或不剩任何字符。
   
  ``` javascript
    var str='abcdabceba'
    // /.+b/ 匹配一个或多个任意字符后面跟一个字母b
    str.match(/.+b/)  // 匹配到 abcdabceb
    // 第一次(先看整个字符串是否是一个匹配) abcdabceba 不匹配,然后去掉最后一个字符a
    // 第二次(去掉最后一个字符后再匹配) abcdabceb 匹配，返回abcdabceb。
  ```

2. 惰性匹配是从左侧第一个字符开始向右匹配, 先看第一个字符是不是一个匹配, 如果不匹配就加入下一个字符再尝式匹配, 直到发现匹配
   
  ``` javascript
    var str='abcdabceba'
    // /.+?b/ 匹配一个或多个任意字符后面跟一个字母b
    str.match(/.+?b/)    // 匹配到ab
    // 第一次(读入左侧第一个字符) a 不匹配加一个再式
    // 第二次 ab 匹配,返回ab
  ```
### 6.匹配位置
在ES5中，共有6个锚字符：

  ``` javascript
    ^ $ \b \B (?=p) (?!p)

    ^（脱字符）匹配开头，在多行匹配中匹配行开头。
    $（美元符号）匹配结尾，在多行匹配中匹配行结尾。
    \b 是单词边界，具体就是\w和\W之间的位置，也包括\w和^之间的位置，也包括\w和$之间的位置。
    \B 就是\b的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉\b，剩下的都是\B的。
    (?=p)，其中p是一个子模式，即p前面的位置。
    (?!p) 就是(?=p)的反面意思。
  ```
### 相关案例
1. 数字的千位分隔符表示法
  比如把"12345678"，变成"12,345,678"。需要在三位数字前面加上逗号，所以就变成了
  ``` javascript
    const reg=/(?=(\d{3})+$)/g
    console.log('12345678'.replace(reg,','))
    // "12,345,678"
  ```
  不过上面的字符如果换成123456789就会变成",123,456,789"。所以我们需要排除第一个位置，首位可以用^表示。非首位可以用位置中的?!p模式,于是就变成了

  ``` javascript
    const reg=/(?!^)(?=(\d{3})+$)/g
    console.log('123456789'.replace(reg,','))
    //"123,456,789"
  ```

2. 提取年、月、日
  ``` javascript
    var regex = /(\d{4})-(\d{2})-(\d{2})/;
    var string = "2017-06-12";
    console.log( string.match(regex) ); 
    // => ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12"]
  ```
  match返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标，最后是输入的文本。（注意：如果正则是否有修饰符g，match返回的数组格式是不一样的）。

  比如，想把yyyy-mm-dd格式，替换成mm/dd/yyyy怎么做？
  ``` javascript
    var regex = /(\d{4})-(\d{2})-(\d{2})/;
    var string = "2017-06-12";
    var result = string.replace(regex, "$2/$3/$1");
    console.log(result); 
    // => "06/12/2017"
  ```
  相当于
  ``` javascript
  var regex = /(\d{4})-(\d{2})-(\d{2})/;
  var string = "2017-06-12";
  var result = string.replace(regex, function(){
    return RegExp.$2 + "/" + RegExp.$3 + "/" + RegExp.$1;
  });
  console.log(result); 
  // => "06/12/2017"
  ```

3. 验证邮箱
  规则：
  - 邮箱的名字以‘数字字母下划线-.’几部分组成，但是-/.不能连续出现也不能作为开头 \w+((-\w+)|(.\w+))*;
  - @ 后面可以加数字字母，可以出现多位 @[A-Za-z0-9]+ ;
  - 对@后面名字的补充：多域名 .com.cn ;企业域名 (.|-)[A-Za-z0-9]+)*
  - .com/.cn 等域名 .[A-Za-z0-9]+
  ``` javascript
    let reg = /^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/
  ```

4. 验证手机号
  规则：
  - 11 位
  - 第一位是数字 1
  - 第二位是数字 3-9 中的任意一位
   ``` javascript
    let reg = /^1[3-9]\d{9}$/;
    console.log(reg.test('13245678945')); //true
    console.log(reg.test('1324567895'));  //false
    console.log(reg.test('12245678945'));  //false

  ```

5. 验证是否为有效数字
   规则：
   - 开头可以有+-
   - 整数位 如果是一位数可以是 0-9 任意数；如果是多位数，首位不可以是 0；
   - 小数位：如果有小数位，那么小数位后面至少有一位数字，也可以没有小数位
   ``` javascript
    let reg = /^[+-]?(\d|[1-9]\d+)(\.\d+)?$/;
    console.log(reg.test('0.2')); //true
    console.log(reg.test('02.1'));  //false
    console.log(reg.test('20.'));  //false

  ```
  ```
6. 验证真实姓名
   规则：
  - 必须是汉字
  - 名字长度 2-10 位
  - 可能有译名：·汉字
  ``` javascript
    let reg = /^[\u4E00-\u9FA5]{2,10}(·[\u4E00-\u9FA5]{2,10})?$/;
    console.log(reg.test('胡歌')); //true
    console.log(reg.test('胡歌·李逍遥'));  //true
  ```

7. 验证身份证号
   规则:
  - 18 位
  - 最后一位是数字或者 X
  - 前 6 位是省市县
  - 后四位是年
  - 后两位是月 01-12
  - 后两位是日 01-31
  - 最后四位
  - 最后一位：X 或者数字
  - 倒数第二位：偶数：女 奇数：男 小括号分组的作用：分组捕获，不仅可以把大正则匹配信息捕获到，还可以单独捕获到每个小分组的内容
   ``` javascript
    let reg =/^([1-9]\d{5})((19|20)\d{2})(0[1-9]|10|11|12)(0[1-9]|[1-2]\d|30|31)\d{3}(\d|x)$/i;、
    或
    let reg = /^([1-9]\d{5})((19|20)\d{2})(0[1-9]|1[0-2])(0[1-9]|1\d|2\d|3[01])\d{3}(\d|x)$/gi
  ```

### Tip: 可前往https://regexr.com/验证