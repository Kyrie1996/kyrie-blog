# 算法与数据结构
### 1.大O记法：时间复杂度
  为了统一描述，大 O 不关注算法所用的时间，只关注其所用的步数。线性查找在数组上要逐个检查每个格子。在最坏情况下，线性查找所需的步数等于格子数。即如前所述：对于 N 个元素的数组，线性查找需要花 N 步。用大 O 记法来表示，即为：`O(N) `, 将其读作“O N”。

  在同一个有序数组里，二分查找比线性查找要快。在同一个有序数组里，二分查找比线性查找要快。但它不能写成 O(1)，因为二分查找的步数会随着数据量的增长而增长。它也不能写成 O(N)，因为步数比元素数量要少得多，正如之前我们看到的，包含 100 个元素的数组只要 7 步就能找完。如此看来，二分查找的时间复杂度介于 O(1)和 O(N)之间。好了，二分查找的大 O 记法是：`O(log N) `, 将其读作“O log N”。归于此类的算法，它们的时间复杂度都叫作`对数时间`。
  
  - 线性时间:，O(N)呈现为一条对角线, 当数据增加一个单位时，算法也随之增加一步。也就是说，数据越多，算法所需的步数就越多。`O(N)`也被称为`线性时间`。
  - 常数时间:，O(1)则为一条水平线, 不管数据量是多少，算法的步数都恒定。所以，`O(1)`也被称为`常数时间`。
  - 对数时间: 二分查找的时间复杂度介于 O(1)和 O(N)之间。好了，二分查找的大 O 记法是：`O(log N) `, 将其读作“O log N”。归于此类的算法，它们的时间复杂度都叫作`对数时间`。
  - 二次时间: O(N2)代表步数的曲线非常陡峭，O(N)的则只呈对角线状。冒泡排序效率的大 O 记法，是 `O(N2)`。`O(N2)`也被叫作二次时间。
  
  大 O 记法能客观地衡量各种算法的时间复杂度，是比较算法的利器。我们也试过用它来对比二分查找和线性查找的步数差异，发现二分查找的步数为 O(log N)，比线性查找的 O(N)快得多。然而，写代码的时候并不总有这样明确的二选一，更多时候你可能就直接采用首先想到的那种算法了。不过有了大 O 的话，你就可以与其他常用的算法比较，然后问自己：“我的算法跟它们相比，是快还是慢？”
  如果你通过大 O 发现自己的算法比其他的要慢，你就应该退一步，好好想想怎样优化它，才能使它变成更快的那种大 O。虽然并不总有提升空间，但在确定编码之前多加考虑还是好的。
### 冒泡排序 O(N2)
  冒泡排序的步骤:
  1. 指向数组中两个相邻的元素（最开始是数组的头两个元素），比较它们的大小。
  2. 如果它们的顺序错了（即左边的值大于右边），就互换位置。如果顺序已经是正确的，那这一步就什么都不用做。
  3. 将两个指针右移一格。重复第1步和第2步，直至指针到达数组末尾。
  4. 重复第1至3步，直至从头到尾都无须再做交换，这时数组就排好序了。
  这里被重复的第1至3步是一个轮回，也就是说，这个算法的主要步骤被“轮回”执行，直到整个数组的顺序正确。

  冒泡排序的执行步骤可分为两种。
  -  比较：比较两个数看哪个更大。
  -  交换：交换两个数的位置以使它们按顺序排列。
描述冒泡排序效率的大 O 记法，是 `O(N2)`。规范一些来说：用 O(N2)算法处理 N 个元素，大约需要 N2步。O(N2)算法是比较低效的，随着数据量变多，其步数也剧增

假设要对[4, 2, 7, 1, 3]进行排序。它现在是无序的，我们的目标是产生一个包含相同元素、升序的数组。

在第 1 次轮回我们为 4 对元素进行了 4 次比较。到了第 2 次轮回，则只做了 3 次比较。这是因为第 1 次轮回已经确定了最后一个格子的元素，所以不用再比较最后两个元素了。
第 3 次轮回，只比较 2 次；第 4 次，只比较 1 次。算起来就是：`4 + 3 + 2 + 1 = 10` 次比较。
推广到 N 个元素，需要`(N - 1) + (N - 2) + (N - 3) + … + 1` 次比较。分析过比较之后，再来看看交换。

如果数组不只是随机打乱，而是完全反序，在这种最坏的情况下，每次比较过后都得进行一
次交换。因此 10 次比较加 10 次交换，总共 20 步。
现在把两种步骤放在一起来看。一个含有 10 个元素的数组，需要：
9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 45 次比较，以及 45 次交换，共 90 步。
9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 45 次比较，以及 45 次交换，共 90 步。
19 + 18 + 17 + 16 + 15 + 14 + 13 + 12 + 11 + 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 190 次比较，
以及 190 次交换，共 380 步。
效率太低了。元素量呈倍数增长，步数却呈指数增长。发现随着 N 的增长，步数大约增长为 N2。因此描述冒泡排序效率的大 O 记法，是 `O(N2)`。
规范一些来说：用 `O(N2)`算法处理 N 个元素，大约需要 N2步。
`O(N2)`算法是比较低效的，随着数据量变多，其步数也剧增。注意 O(N2)代表步数的曲线非常陡峭，O(N)的则只呈对角线状。最后一点：O(N2)也被叫作二次时间。

```javascript
  //思路：先比较一轮一次，然后用for循环比较一轮多次，然后再加for循环比较多轮多次
  //从大到小排序
  var array=[10,20,9,8,79,65,100];
  //比较轮数
  for ( var i=0;i<array.length-1;i++){
      //每轮比较次数，次数=长度-1-此时的轮数
      for (var j=0;j<array.length-1-i;j++) {
          if (array[j] > array[j + 1]) {
              var temp = array[i];
              array[j] = array[j + 1];
              array[j + 1] = temp;
          } //end if
      }//end for 次数
  } //end for 轮数
```
### 选择排序 O(N2)
选择排序的步骤:
1. 从左至右检查数组的每个格子，找出值最小的那个。在此过程中，我们会用一个变量来记住检查过的数字的最小值（事实上记住的是索引，但为了看起来方便，下图就直接写出数值）。如果一个格子中的数字比记录的最小值还要小，就把变量改成该格子的索引，
2. 知道哪个格子的值最小之后，将该格与本次检查的起点交换。第 1 次检查的起点是索引 0，第 2 次是索引 1，以此类推。
3. 重复第1、2步，直至数组排好序。
```javascript
function selectionSort(array) { 
 for(var i = 0; i < array.length; i++) { 
  var lowestNumberIndex = i; 
  for(var j = i + 1; j < array.length; j++) { 
    if(array[j] < array[lowestNumberIndex]) { 
    lowestNumberIndex = j; 
    } 
  } 
  if(lowestNumberIndex != i) { 
    var temp = array[i]; 
    array[i] = array[lowestNumberIndex]; 
    array[lowestNumberIndex] = temp; 
  } 
 } 
 return array; 
}
```
### 插入排序 O(N2)